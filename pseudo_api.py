import xlwings as xw, csv, asyncio, aiohttp

def open_excel(xl_path, sheet_name):
    # Start a visible Excel instance
    app = xw.App(visible=True)

    # Open the predefined path in Excel instance
    wb = app.books.open(xl_path)

    # Close new workbook that opens by default from running xw.App()
    if any(book.name == "Book1" for book in app.books):
        app.books["Book1"].close()

    # Return the worksheet as an output using the prefined sheet name
    return app, wb.sheets[sheet_name]

def read_table(ws, table_name):
    # Get the table object using the predefined table name
    table = ws.api.ListObjects(table_name)

    # Get the cell range of the table
    data_range = table.Range

    # Return the data within the table cell range as a list of lists
    return ws.range((data_range.Row, data_range.Column)).expand().value

def read_csv(csv_path):
    # Open csv at the predefined path
    with open(csv_path, mode='r', newline='') as f:
            # Read csv and return data as a list of lists
            return list(csv.reader(f))
    
def append_csv(csv_path, data):
    # Open csv at the predefined path in append mode
    with open(csv_path, mode='a', newline='') as f:
        # Write input data as rows to csv
        csv.writer(f).writerow(data)

async def postcode_lookup(sharepoint_item_id, recipient_email, postcode):
    # Define the endpoint url for the api we're going to get data from
    postcode_lookup_url = f"https://api.postcodes.io/postcodes/{postcode}"

    async with aiohttp.ClientSession() as session:
        # Make the GET request and wait for the response
        async with session.get(postcode_lookup_url) as postcode_lookup_response:
            postcode_lookup_data = await postcode_lookup_response.json()

        # Construct the data payload to send to power automate, as json
        payload = {
            "sharepoint_item_id": sharepoint_item_id,
            "recipient_email": recipient_email,
            "response": postcode_lookup_data,
            "status": "completed"
        }

        # Define the endpoint url generated by the power automate HTTP trigger
        power_automate_url = 'https://prod-04.uksouth.logic.azure.com:443/workflows/9410c0b684f942f39f7cc02a915655a7/triggers/manual/paths/invoke?api-version=2016-06-01&sp=%2Ftriggers%2Fmanual%2Frun&sv=1.0&sig=fJwmKjClnP7r50ZV9e04uG8pxvGKGa662VATeyx5gUc'

        # Make the HTTP request and await the response
        async with session.post(power_automate_url, json=payload) as power_automate_response:
            # Return response as an output once received
            return await power_automate_response.json()

async def main():
    # Path to 'requests.xlsx'
    xl_path = r"C:\Users\Elliot\OneDrive - EC\requests.xlsx"

    # Path to 'requests_actioned.csv'
    csv_path = r"C:\Users\Elliot\OneDrive - EC\requests_actioned.csv"

    # Name of the sheet with the target table
    sheet_name = "requests"

    # Name of the table
    table_name = "request_log"

    # Execution delay in seconds
    poll_interval = 1

    # Map of function strings to functions
    function_map = {
        "postcode_lookup": postcode_lookup
    }

    while True:
        try:
            # Define the open_excel function output as 'ws'
            app, ws = open_excel(xl_path, sheet_name)

            # Define the requests_actioned sharepoint_item_id column as a list
            processed_ids = list(row[0] for row in read_csv(csv_path))

            # Define list for async tasks
            tasks = []
            
            # Start infinite loop to continiously check for new requests
            while True:
                # Define the read_table function output as 'requests'
                requests = read_table(ws, table_name)
                
                if isinstance(requests[0], list):
                    # Calculate the difference between the length of the 'requests' and 'requests_actioned' lists
                    row_delta = len(requests) - len(processed_ids)

                    print(row_delta, 'new requests detected.')

                    # If there's more items in the 'requests' list...
                    if row_delta > 0:
                        # Define new requests as the last 'row_delta' items in the 'requests' list
                        new_requests = requests[-row_delta:]

                        # Iterate over items in the 'new_requests' list
                        for request in new_requests:
                            # Unpack the row list into separate variables
                            sharepoint_item_id, function, parameters = request

                            # Append the function and parameters requested to the 'tasks' list as an asyncio task
                            tasks.append(asyncio.create_task(function_map.get(function)(sharepoint_item_id, *parameters.split(", "))))

                            # Add the new sharepoint_item_id to the processed list
                            processed_ids.append(sharepoint_item_id)

                    # Define a list of completed tasks
                    completed_tasks = [task for task in tasks if task.done()]
                    
                    # Iterate over the list completed tasks
                    for task in completed_tasks:
                        # Retrieve the response from the power automate flow
                        result = task.result()

                        # Append the request log to 'actioned_requests.csv'
                        append_csv(csv_path, [result["sharepoint_item_id"], result["function"], result["parameters"], result["created"], result["completed"], result['status'], result["failure_reason"]])
                    
                    # Define a list of active tasks to avoid duplicate processing
                    tasks = [task for task in tasks if not task.done()]

                    print(len(tasks), "requests being processed...")
                else:
                    print("Waiting for first request...")

                print('')

                # Wait before checking 'requests.xlsx' again, to avoid unnecessary CPU usage
                await asyncio.sleep(poll_interval)

        except Exception as e:
            # Print the error
            print(e)

            # Close the excel instance
            app.quit()

            # Wait before opening excel again
            await asyncio.sleep(5)

# Run the 'main' function
if __name__ == "__main__":
    asyncio.run(main())